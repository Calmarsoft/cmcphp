<?php
/**
 -------------------------------------------------------------------------
    CMC for PHP is a web framework for PHP.                              
    More information can be seen here: <http://cmc.calmarsoft.com/about>
 -------------------------------------------------------------------------

    Copyright (c) 2014 by Calmarsoft company <http://calmarsoft.com> (FRANCE). All rights reserved.
     
    This file is part of CMC for PHP.

    CMC for PHP is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CMC for PHP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CMC for PHP.  If not, see <http://www.gnu.org/licenses/>.
**/
namespace cmc\error;

use cmc\core\request;
use \cmc\config;
use \cmc\app;

/**
 * Handle the global runtime errors generated by PHP
 * 
 * It can be disabled, transform them as exceptions or generate fatal errors directly
 *
 * @copyright     Copyright (c) Calmarsoft company (FRANCE) (http://calmarsoft.com)
 * @link          http://cmc.calmarsoft.com CMC Project
 * @license       http://www.gnu.org/licenses/ GNU General Public License version 3
 * @version       0.9
 */
class runtimeErrors {

    const H_Fatal = 1;
    const H_Log = 2;
    const H_Except = 4;

    static private $_active = false;
    static private $_mask = 0;
    static private $_orgmask = 0;

    /**
     * main init routine
     * 
     * checks if the configuration enables global runtime errors handler
     * (@see \cmc\config::errorHandle)
     */
    static function initialize() {
        if (self::$_active)
            restore_error_handler();

        $level = E_ERROR;
        self::$_mask = config::errorDefaultMask;
       
        // enable both runtime and fatal error handlers
        if (config::errorHandle != 0) {
            set_error_handler(array(__CLASS__, 'HandleError'));
            register_shutdown_function(array(__CLASS__, 'check_for_fatal'), $level);
            self::$_active = true;
        }
    }
    /**
     * unactivate runtime error handling
     */
    static function disable() {
        if (self::$_active) {
            restore_error_handler();
        }
    }
    /**
     * temporarily sets a new error code mask. Usually used to avoid handling in a specific portion of the program
     * @param integer $mask
     */
    static function setMask($mask) {
        self::$_orgmask = self::$_mask;
        self::$_mask = $mask;        
    }
    /**
     * restore initial error code mask (state before calling setMask)
     * 
     * warning: setMask/resetMask function cannot be imbricated 
     */
    static function resetMask() {
        self::$_mask = self::$_orgmask;        
    }
    

    /**
     * runtimeError handler
     * 
     * depending on configuration it can generate log, fatal, ...
     * @param integer $code error core
     * @param string $string error text
     * @param string $file error filename
     * @param integer $line error line number
     * @param string $context error context
     * @return boolean
     * if returns true (if mask matches error code), the error is ignored
     */
    static function HandleError($code, $string, $file, $line, $context) {
        restore_error_handler();
        if (($code & self::$_mask)!==0) // this error is masked (handled by function)
            return true;

        if (config::errorHandle & self::H_Fatal) {
            $sess = app::current()->getSession();

            // callstack with removal of top (this function)
            $file = \str_replace(request::rootphyspath().'/', '', $file);
            fatalErrors::trigger($sess, 'runtime', 2, $code, $string, $file, $line, $context);
        }
    }
    /**
     * in shutdown process, check if shutdown is normal or caused by a fatal error
     */
    static function check_for_fatal() {
        $error = error_get_last();
        if ($error["type"] == E_ERROR) {
            $context = ".";
            fatalErrors::setContinue();
            self::HandleError($error["type"], $error["message"], $error["file"], $error["line"], $context);            
        }
    }
    
    static function uncaughtException($e) {
        $sess = app::current()->getSession();
         
        if (config::errorHandle & self::H_Fatal) {
            fatalErrors::triggerException($sess, $e);
        }        
    }


}

